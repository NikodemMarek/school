{"ast":null,"code":"import { Mark } from \"./types\";\nexport class Opponent {\n  constructor(size) {\n    this.size = size;\n    this.attackMap = null;\n    this.makeMove = (board, lastMove) => {\n      const moves = this.getMoves(board);\n      const getRandomMove = () => moves[Math.floor(Math.random() * moves.length)];\n      if (!this.attackMap) {\n        const bestPoints = this.getBestPoints(board);\n        this.attackMap = bestPoints[Math.floor(Math.random() * bestPoints.length)];\n      }\n      if (this.attackMap.some(({\n        x,\n        y\n      }) => x === lastMove.x && y === lastMove.y)) {\n        const bestPoints = this.getBestPoints(board);\n        this.attackMap = bestPoints[Math.floor(Math.random() * bestPoints.length)];\n      }\n      const saveMoves = this.shouldIBeAlamed(board, lastMove);\n      if (saveMoves.length > 0) return saveMoves[0];\n      return this.attackMap.find(({\n        x,\n        y\n      }) => board[y][x] === Mark.None) || getRandomMove();\n    };\n    this.getBestPoints = board => {\n      const freeCombinations = [[{\n        x: -2,\n        y: 0\n      }, {\n        x: -1,\n        y: 0\n      }, {\n        x: 1,\n        y: 0\n      }, {\n        x: 2,\n        y: 0\n      }], [{\n        x: 0,\n        y: -2\n      }, {\n        x: 0,\n        y: -1\n      }, {\n        x: 0,\n        y: 1\n      }, {\n        x: 0,\n        y: 2\n      }], [{\n        x: -2,\n        y: -2\n      }, {\n        x: -1,\n        y: -1\n      }, {\n        x: 1,\n        y: 1\n      }, {\n        x: 2,\n        y: 2\n      }], [{\n        x: -2,\n        y: 2\n      }, {\n        x: -1,\n        y: 1\n      }, {\n        x: 1,\n        y: -1\n      }, {\n        x: 2,\n        y: -2\n      }]];\n      const pointsToCheck = [];\n      for (let y = 0; y < board.length; y++) {\n        const row = board[y];\n        for (let x = 0; x < row.length; x++) {\n          if (board[y][x] === Mark.None || board[y][x] === Mark.X) pointsToCheck.push({\n            x,\n            y\n          });\n        }\n      }\n      const bests = pointsToCheck.map(({\n        x,\n        y\n      }) => {\n        const combinations = freeCombinations.filter(([a, b, c, d]) => (board[y + a.y]?.[x + a.x] === Mark.X || board[y + a.y]?.[x + a.x] === Mark.None) && (board[y + b.y]?.[x + b.x] === Mark.X || board[y + b.y]?.[x + b.x] === Mark.None) && (board[y + c.y]?.[x + c.x] === Mark.X || board[y + c.y]?.[x + c.x] === Mark.None) && (board[y + d.y]?.[x + d.x] === Mark.X || board[y + d.y]?.[x + d.x] === Mark.None));\n        return combinations.map(([a, b, c, d]) => {\n          return [{\n            x: x + a.x,\n            y: y + a.y\n          }, {\n            x: x + b.x,\n            y: y + b.y\n          }, {\n            x,\n            y\n          }, {\n            x: x + c.x,\n            y: y + c.y\n          }, {\n            x: x + d.x,\n            y: y + d.y\n          }];\n        });\n      });\n      return bests.flat();\n    };\n    this.getMoves = board => {\n      const moves = [];\n      for (let y = 0; y < board.length; y++) {\n        const row = board[y];\n        for (let x = 0; x < row.length; x++) {\n          if (board[y][x] === Mark.None) moves.push({\n            x,\n            y\n          });\n        }\n      }\n      return moves;\n    };\n    this.tilesWithMarkAound = (board, around, mark) => {\n      const {\n        x,\n        y\n      } = around;\n      const possibilities = [{\n        x: 1,\n        y: 1\n      }, {\n        x: 0,\n        y: 1\n      }, {\n        x: -1,\n        y: 1\n      }, {\n        x: -1,\n        y: 0\n      }, {\n        x: -1,\n        y: -1\n      }, {\n        x: 0,\n        y: -1\n      }, {\n        x: 1,\n        y: -1\n      }, {\n        x: 1,\n        y: 0\n      }];\n      const tilesAround = [];\n      for (const possibility of possibilities) {\n        const newX = x + possibility.x;\n        const newY = y + possibility.y;\n        if (newX >= 0 && newX < this.size.x && newY >= 0 && newY < this.size.y) if (board[newY][newX] === mark) tilesAround.push({\n          x: newX,\n          y: newY\n        });\n      }\n      return tilesAround;\n    };\n    this.getMovesAround = (board, origin) => this.tilesWithMarkAound(board, origin, Mark.None);\n    this.getMyMarksAround = (board, origin) => this.tilesWithMarkAound(board, origin, Mark.X);\n    this.getOppositeMoves = (moves, origin) => moves.map(({\n      x,\n      y\n    }) => ({\n      x: 2 * origin.x - x,\n      y: 2 * origin.y - y\n    }));\n    this.getOppositeFreeMoves = (board, origin) => {\n      // console.log('or', origin)\n      const rel = this.getMovesAround(board, origin);\n      // console.log('rel', rel)\n      const opp = this.getOppositeMoves(rel, origin);\n      // console.log('opp', opp)\n      const filt = opp.filter(({\n        x,\n        y\n      }) => board[y]?.[x] === Mark.None);\n      // console.log('filt', filt)\n      return filt;\n    };\n    this.shouldIBeAlamed = (board, lastMove) => {\n      const {\n        x,\n        y\n      } = lastMove;\n      const danger = [[{\n        x: 1,\n        y: 1\n      }, {\n        x: 2,\n        y: 2\n      }], [{\n        x: 0,\n        y: 1\n      }, {\n        x: 0,\n        y: 2\n      }], [{\n        x: -1,\n        y: 1\n      }, {\n        x: -2,\n        y: 2\n      }], [{\n        x: -1,\n        y: 0\n      }, {\n        x: -2,\n        y: 0\n      }], [{\n        x: -1,\n        y: -1\n      }, {\n        x: -2,\n        y: -2\n      }], [{\n        x: 0,\n        y: -1\n      }, {\n        x: 0,\n        y: -2\n      }], [{\n        x: 1,\n        y: -1\n      }, {\n        x: 2,\n        y: -2\n      }], [{\n        x: 1,\n        y: 0\n      }, {\n        x: 2,\n        y: 0\n      }]];\n      const available = [];\n      for (const direction of danger) {\n        if (board[y + direction[0].y]?.[x + direction[0].x] === Mark.O && board[y + direction[1].y]?.[x + direction[1].x] === Mark.O) {\n          const front = {\n            x: lastMove.x - direction[0].x,\n            y: lastMove.y - direction[0].y\n          };\n          const end = {\n            x: lastMove.x + direction[0].x * 3,\n            y: lastMove.y + direction[0].y * 3\n          };\n          if (front.x >= 0 && front.x < this.size.x && front.y >= 0 && front.y < this.size.y && board[front.y][front.x] === Mark.None) available.push(front);\n          if (end.x >= 0 && end.x < this.size.x && end.y >= 0 && end.y < this.size.y && board[end.y][end.x] === Mark.None) available.push(end);\n        }\n      }\n      return available;\n    };\n  }\n}","map":{"version":3,"mappings":"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","names":["Mark","Opponent","constructor","size","attackMap","makeMove","board","lastMove","moves","getMoves","getRandomMove","Math","floor","random","length","bestPoints","getBestPoints","some","x","y","saveMoves","shouldIBeAlamed","find","None","freeCombinations","pointsToCheck","row","X","push","bests","map","combinations","filter","a","b","c","d","flat","tilesWithMarkAound","around","mark","possibilities","tilesAround","possibility","newX","newY","getMovesAround","origin","getMyMarksAround","getOppositeMoves","getOppositeFreeMoves","rel","opp","filt","danger","available","direction","O","front","end"],"sourceRoot":"","sources":["/home/nikodem/projects/school/src/app/opponentai.ts"],"sourcesContent":["import { Mark } from \"./types\";\n\nexport class Opponent {\n  private attackMap: { x: number, y: number }[] | null = null;\n\n  constructor(private size: { x: number, y: number }) {}\n\n  makeMove = (board: Mark[][], lastMove: { x: number, y: number }): { x: number, y: number } => {\n    const moves = this.getMoves(board);\n\n    const getRandomMove = () => moves[Math.floor(Math.random() * moves.length)];\n\n    if (!this.attackMap) {\n      const bestPoints = this.getBestPoints(board)\n      this.attackMap = bestPoints[Math.floor(Math.random() * bestPoints.length)]\n    }\n    if (this.attackMap.some(({ x, y }) => x === lastMove.x && y === lastMove.y)) {\n      const bestPoints = this.getBestPoints(board)\n      this.attackMap = bestPoints[Math.floor(Math.random() * bestPoints.length)]\n    }\n\n    const saveMoves = this.shouldIBeAlamed(board, lastMove);\n    if (saveMoves.length > 0)\n      return saveMoves[0]\n\n\n    return this.attackMap.find(({ x, y }) => board[y][x] === Mark.None) || getRandomMove()\n  }\n\n  private getBestPoints = (board: Mark[][]) => {\n    const freeCombinations = [\n      [\n        { x: -2, y: 0 },\n        { x: -1, y: 0 },\n        { x: 1, y: 0 },\n        { x: 2, y: 0 },\n      ],\n      [\n        { x: 0, y: -2 },\n        { x: 0, y: -1 },\n        { x: 0, y: 1 },\n        { x: 0, y: 2 },\n      ],\n      [\n        { x: -2, y: -2 },\n        { x: -1, y: -1 },\n        { x: 1, y: 1 },\n        { x: 2, y: 2 },\n      ],\n      [\n        { x: -2, y: 2 },\n        { x: -1, y: 1 },\n        { x: 1, y: -1 },\n        { x: 2, y: -2 },\n      ],\n    ]\n\n    const pointsToCheck: { x: number, y: number }[] = []\n    for (let y = 0; y < board.length; y++) {\n      const row = board[y];\n      for (let x = 0; x < row.length; x++) {\n        if (board[y][x] === Mark.None || board[y][x] === Mark.X)\n          pointsToCheck.push({ x, y })\n      }\n    }\n\n    const bests = pointsToCheck.map(({ x, y }) => {\n       const combinations = freeCombinations.filter(([a, b, c, d]) =>\n          (board[y + a.y]?.[x + a.x] === Mark.X || board[y + a.y]?.[x + a.x] === Mark.None)\n          && (board[y + b.y]?.[x + b.x] === Mark.X || board[y + b.y]?.[x + b.x] === Mark.None)\n          && (board[y + c.y]?.[x + c.x] === Mark.X || board[y + c.y]?.[x + c.x] === Mark.None)\n          && (board[y + d.y]?.[x + d.x] === Mark.X || board[y + d.y]?.[x + d.x] === Mark.None)\n      )\n\n      return combinations.map(([a, b, c, d]) => {\n        return [\n          {\n            x: x + a.x,\n            y: y + a.y,\n          },\n          {\n            x: x + b.x,\n            y: y + b.y,\n          },\n          { x, y },\n          {\n            x: x + c.x,\n            y: y + c.y,\n          },\n          {\n            x: x + d.x,\n            y: y + d.y,\n          },\n        ]\n      })\n    })\n\n    return bests.flat()\n  }\n\n  private getMoves = (board: Mark[][]): { x: number, y: number }[] => {\n    const moves: { x: number, y: number }[] = [];\n\n    for (let y = 0; y < board.length; y++) {\n      const row = board[y];\n      for (let x = 0; x < row.length; x++) {\n        if (board[y][x] === Mark.None) moves.push({ x, y });\n      }\n    }\n\n    return moves;\n  }\n\n  private tilesWithMarkAound = (board: Mark[][], around: { x: number, y: number }, mark: Mark): { x: number, y: number }[] => {\n    const { x, y } = around;\n\n    const possibilities = [\n      { x: 1, y: 1 },\n      { x: 0, y: 1 },\n      { x: -1, y: 1 },\n      { x: -1, y: 0 },\n      { x: -1, y: -1 },\n      { x: 0, y: -1 },\n      { x: 1, y: -1 },\n      { x: 1, y: 0 },\n    ];\n\n    const tilesAround: { x: number, y: number }[] = [];\n    for (const possibility of possibilities) {\n      const newX = x + possibility.x;\n      const newY = y + possibility.y;\n\n      if (newX >= 0 && newX < this.size.x && newY >= 0 && newY < this.size.y)\n        if (board[newY][newX] === mark)\n          tilesAround.push({ x: newX, y: newY });\n    }\n\n    return tilesAround;\n  }\n\n  private getMovesAround = (board: Mark[][], origin: { x: number, y: number }): { x: number, y: number }[] =>\n    this.tilesWithMarkAound(board, origin, Mark.None);\n\n  private getMyMarksAround = (board: Mark[][], origin: { x: number, y: number }): { x: number, y: number }[] =>\n    this.tilesWithMarkAound(board, origin, Mark.X);\n\n  private getOppositeMoves = (moves: { x: number, y: number }[], origin: { x: number, y: number }): { x: number, y: number }[] =>\n    moves.map(({ x, y }) => ({\n      x: 2 * origin.x - x,\n      y: 2 * origin.y - y,\n    }))\n  private getOppositeFreeMoves = (board: Mark[][], origin: { x: number, y: number }): { x: number, y: number }[] => {\n    // console.log('or', origin)\n\n    const rel = this.getMovesAround(board, origin)\n    // console.log('rel', rel)\n\n    const opp = this.getOppositeMoves(rel, origin)\n    // console.log('opp', opp)\n    const filt = opp.filter(({ x, y }) => board[y]?.[x] === Mark.None)\n    // console.log('filt', filt)\n    return filt\n  }\n\n  private shouldIBeAlamed = (board: Mark[][], lastMove: { x: number, y: number }): { x: number, y: number }[] => {\n    const { x, y } = lastMove;\n\n    const danger = [\n      [\n        { x: 1, y: 1 },\n        { x: 2, y: 2 },\n      ],\n      [\n        { x: 0, y: 1 },\n        { x: 0, y: 2 },\n      ],\n      [\n        { x: -1, y: 1 },\n        { x: -2, y: 2 },\n      ],\n      [\n        { x: -1, y: 0 },\n        { x: -2, y: 0 },\n      ],\n      [\n        { x: -1, y: -1 },\n        { x: -2, y: -2 },\n      ],\n      [\n        { x: 0, y: -1 },\n        { x: 0, y: -2 },\n      ],\n      [\n        { x: 1, y: -1 },\n        { x: 2, y: -2 },\n      ],\n      [\n        { x: 1, y: 0 },\n        { x: 2, y: 0 },\n      ],\n    ];\n\n    const available: { x: number, y: number }[] = [];\n    for (const direction of danger) {\n      if (\n        board[y + direction[0].y]?.[x + direction[0].x] === Mark.O\n        && board[y + direction[1].y]?.[x + direction[1].x] === Mark.O\n      ) {\n        const front = {\n          x: lastMove.x - direction[0].x,\n          y: lastMove.y - direction[0].y,\n        }\n        const end = {\n          x: lastMove.x + direction[0].x * 3,\n          y: lastMove.y + direction[0].y * 3,\n        }\n\n        if (front.x >= 0 && front.x < this.size.x && front.y >= 0 && front.y < this.size.y && board[front.y][front.x] === Mark.None)\n          available.push(front)\n        if (end.x >= 0 && end.x < this.size.x && end.y >= 0 && end.y < this.size.y && board[end.y][end.x] === Mark.None)\n          available.push(end)\n      }\n    }\n\n    return available\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}