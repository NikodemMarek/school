{"ast":null,"code":"import { Mark } from \"./types\";\nexport class Opponent {\n  constructor(size) {\n    this.size = size;\n    this.nextAttack = null;\n    this.makeMove = (board, lastMove) => {\n      const moves = this.getMoves(board);\n      const getRandomMove = () => moves[Math.floor(Math.random() * moves.length)];\n      const saveMoves = this.shouldIBeAlamed(board, lastMove);\n      if (saveMoves.length > 0) {\n        console.log('3', saveMoves);\n        return saveMoves[0];\n      }\n      if (this.nextAttack == lastMove) this.nextAttack = null;\n      if (!this.nextAttack) {\n        console.log('0');\n        const thisAttack = getRandomMove();\n        this.nextAttack = this.getNextAttack(board, thisAttack);\n        console.log('0', thisAttack);\n        return thisAttack;\n      } else {\n        console.log('1');\n        const thisAttack = this.nextAttack;\n        this.nextAttack = this.getNextAttack(board, thisAttack);\n        console.log('1', thisAttack);\n        return thisAttack;\n      }\n      console.log('asdfa');\n      return {\n        x: 0,\n        y: 0\n      };\n    };\n    this.getMoves = board => {\n      const moves = [];\n      for (let y = 0; y < board.length; y++) {\n        const row = board[y];\n        for (let x = 0; x < row.length; x++) {\n          if (board[y][x] === Mark.None) moves.push({\n            x,\n            y\n          });\n        }\n      }\n      return moves;\n    };\n    this.tilesWithMarkAound = (board, around, mark) => {\n      const {\n        x,\n        y\n      } = around;\n      const possibilities = [{\n        x: 1,\n        y: 1\n      }, {\n        x: 0,\n        y: 1\n      }, {\n        x: -1,\n        y: 1\n      }, {\n        x: -1,\n        y: 0\n      }, {\n        x: -1,\n        y: -1\n      }, {\n        x: 0,\n        y: -1\n      }, {\n        x: 1,\n        y: -1\n      }, {\n        x: 1,\n        y: 0\n      }];\n      const tilesAround = [];\n      for (const possibility of possibilities) {\n        const newX = x + possibility.x;\n        const newY = y + possibility.y;\n        if (newX >= 0 && newX < this.size.x && newY >= 0 && newY < this.size.y) if (board[newY][newX] === mark) tilesAround.push({\n          x: newX,\n          y: newY\n        });\n      }\n      return tilesAround;\n    };\n    this.getMovesAround = (board, origin) => this.tilesWithMarkAound(board, origin, Mark.None);\n    this.getMyMarksAround = (board, origin) => this.tilesWithMarkAound(board, origin, Mark.X);\n    this.getOppositeMoves = (moves, origin) => moves.map(({\n      x,\n      y\n    }) => ({\n      x: 2 * origin.x - x,\n      y: 2 * origin.y - y\n    }));\n    this.getOppositeFreeMoves = (board, origin) => {\n      // console.log('or', origin)\n      const rel = this.getMovesAround(board, origin);\n      // console.log('rel', rel)\n      const opp = this.getOppositeMoves(rel, origin);\n      // console.log('opp', opp)\n      const filt = opp.filter(({\n        x,\n        y\n      }) => board[y][x] === Mark.None);\n      // console.log('filt', filt)\n      return filt;\n    };\n    this.getNextAttack = (board, nextAttack) => {\n      const myTilesAround = this.getMyMarksAround(board, nextAttack);\n      if (myTilesAround.length <= 0) {\n        const movesAround = this.getMovesAround(board, nextAttack);\n        if (movesAround.length <= 0) {\n          return null;\n        } else {\n          return movesAround[0];\n        }\n      } else {\n        const freeOpposite = this.getOppositeFreeMoves(board, nextAttack);\n        if (freeOpposite.length <= 0) {\n          const movesAround = this.getMovesAround(board, nextAttack);\n          if (movesAround.length <= 0) {\n            return null;\n          } else {\n            return movesAround[0];\n          }\n        } else {\n          return freeOpposite[0];\n        }\n      }\n    };\n    this.shouldIBeAlamed = (board, lastMove) => {\n      const {\n        x,\n        y\n      } = lastMove;\n      const danger = [[{\n        x: 1,\n        y: 1\n      }, {\n        x: 2,\n        y: 2\n      }], [{\n        x: 0,\n        y: 1\n      }, {\n        x: 0,\n        y: 2\n      }], [{\n        x: -1,\n        y: 1\n      }, {\n        x: -2,\n        y: 2\n      }], [{\n        x: -1,\n        y: 0\n      }, {\n        x: -2,\n        y: 0\n      }], [{\n        x: -1,\n        y: -1\n      }, {\n        x: -2,\n        y: -2\n      }], [{\n        x: 0,\n        y: -1\n      }, {\n        x: 0,\n        y: -2\n      }], [{\n        x: 1,\n        y: -1\n      }, {\n        x: 2,\n        y: -2\n      }], [{\n        x: 1,\n        y: 0\n      }, {\n        x: 2,\n        y: 0\n      }]];\n      const available = [];\n      for (const direction of danger) {\n        if (board[y + direction[0].y]?.[x + direction[0].x] === Mark.X && board[y + direction[1].y]?.[x + direction[1].x] === Mark.X) {\n          const front = {\n            x: lastMove.x + direction[0].x * -1,\n            y: lastMove.y + direction[0].y * -1\n          };\n          const end = {\n            x: lastMove.x + direction[0].x * 3,\n            y: lastMove.y + direction[0].y * 3\n          };\n          if (front.x > 0 && front.x <= this.size.x && front.y > 0 && front.y <= this.size.y) if (board[front.y]?.[front.x] === Mark.None) available.push(front);\n          if (end.x > 0 && end.x <= this.size.x && end.y > 0 && end.y <= this.size.y) if (board[end.y]?.[end.x] === Mark.None) available.push(end);\n        }\n      }\n      return available;\n    };\n  }\n}","map":{"version":3,"mappings":"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","names":["Mark","Opponent","constructor","size","nextAttack","makeMove","board","lastMove","moves","getMoves","getRandomMove","Math","floor","random","length","saveMoves","shouldIBeAlamed","console","log","thisAttack","getNextAttack","x","y","row","None","push","tilesWithMarkAound","around","mark","possibilities","tilesAround","possibility","newX","newY","getMovesAround","origin","getMyMarksAround","X","getOppositeMoves","map","getOppositeFreeMoves","rel","opp","filt","filter","myTilesAround","movesAround","freeOpposite","danger","available","direction","front","end"],"sourceRoot":"","sources":["/home/nikodem/projects/school/src/app/opponentai.ts"],"sourcesContent":["import { Mark } from \"./types\";\n\nexport class Opponent {\n  private nextAttack: { x: number, y: number } | null = null;\n\n  constructor(private size: { x: number, y: number }) {}\n\n  makeMove = (board: Mark[][], lastMove: { x: number, y: number }): { x: number, y: number } => {\n    const moves = this.getMoves(board);\n\n    const getRandomMove = () => moves[Math.floor(Math.random() * moves.length)];\n\n    const saveMoves = this.shouldIBeAlamed(board, lastMove);\n    if (saveMoves.length > 0) {\n      console.log('3', saveMoves)\n      return saveMoves[0]\n    }\n\n    if (this.nextAttack == lastMove)\n      this.nextAttack = null\n\n    if (!this.nextAttack) {\n      console.log('0')\n      const thisAttack = getRandomMove()\n      this.nextAttack = this.getNextAttack(board, thisAttack)\n      console.log('0', thisAttack)\n      return thisAttack\n    } else {\n      console.log('1')\n      const thisAttack = this.nextAttack\n      this.nextAttack = this.getNextAttack(board, thisAttack)\n      console.log('1', thisAttack)\n      return thisAttack\n    }\n\n    console.log('asdfa')\n    return { x: 0, y: 0 }\n  }\n\n  private getMoves = (board: Mark[][]): { x: number, y: number }[] => {\n    const moves: { x: number, y: number }[] = [];\n\n    for (let y = 0; y < board.length; y++) {\n      const row = board[y];\n      for (let x = 0; x < row.length; x++) {\n        if (board[y][x] === Mark.None) moves.push({ x, y });\n      }\n    }\n\n    return moves;\n  }\n\n  private tilesWithMarkAound = (board: Mark[][], around: { x: number, y: number }, mark: Mark): { x: number, y: number }[] => {\n    const { x, y } = around;\n\n    const possibilities = [\n      { x: 1, y: 1 },\n      { x: 0, y: 1 },\n      { x: -1, y: 1 },\n      { x: -1, y: 0 },\n      { x: -1, y: -1 },\n      { x: 0, y: -1 },\n      { x: 1, y: -1 },\n      { x: 1, y: 0 },\n    ];\n\n    const tilesAround: { x: number, y: number }[] = [];\n    for (const possibility of possibilities) {\n      const newX = x + possibility.x;\n      const newY = y + possibility.y;\n\n      if (newX >= 0 && newX < this.size.x && newY >= 0 && newY < this.size.y)\n        if (board[newY][newX] === mark)\n          tilesAround.push({ x: newX, y: newY });\n    }\n\n    return tilesAround;\n  }\n\n  private getMovesAround = (board: Mark[][], origin: { x: number, y: number }): { x: number, y: number }[] =>\n    this.tilesWithMarkAound(board, origin, Mark.None);\n\n  private getMyMarksAround = (board: Mark[][], origin: { x: number, y: number }): { x: number, y: number }[] =>\n    this.tilesWithMarkAound(board, origin, Mark.X);\n\n  private getOppositeMoves = (moves: { x: number, y: number }[], origin: { x: number, y: number }): { x: number, y: number }[] =>\n    moves.map(({ x, y }) => ({\n      x: 2 * origin.x - x,\n      y: 2 * origin.y - y,\n    }))\n  private getOppositeFreeMoves = (board: Mark[][], origin: { x: number, y: number }): { x: number, y: number }[] => {\n    // console.log('or', origin)\n\n    const rel = this.getMovesAround(board, origin)\n    // console.log('rel', rel)\n\n    const opp = this.getOppositeMoves(rel, origin)\n    // console.log('opp', opp)\n    const filt = opp.filter(({ x, y }) => board[y][x] === Mark.None)\n    // console.log('filt', filt)\n    return filt\n  }\n\n  private getNextAttack = (board: Mark[][], nextAttack: { x: number, y: number }): { x: number, y: number } | null => {\n    const myTilesAround = this.getMyMarksAround(board, nextAttack)\n\n    if (myTilesAround.length <= 0) {\n      const movesAround = this.getMovesAround(board, nextAttack)\n\n      if (movesAround.length <= 0) {\n        return null\n      } else {\n        return movesAround[0]\n      }\n    } else {\n      const freeOpposite = this.getOppositeFreeMoves(board, nextAttack)\n\n      if (freeOpposite.length <= 0) {\n        const movesAround = this.getMovesAround(board, nextAttack)\n\n        if (movesAround.length <= 0) {\n          return null\n        } else {\n          return movesAround[0]\n        }\n      } else {\n        return freeOpposite[0]\n      }\n    }\n  }\n\n  private shouldIBeAlamed = (board: Mark[][], lastMove: { x: number, y: number }): { x: number, y: number }[] => {\n    const { x, y } = lastMove;\n\n    const danger = [\n      [\n        { x: 1, y: 1 },\n        { x: 2, y: 2 },\n      ],\n      [\n        { x: 0, y: 1 },\n        { x: 0, y: 2 },\n      ],\n      [\n        { x: -1, y: 1 },\n        { x: -2, y: 2 },\n      ],\n      [\n        { x: -1, y: 0 },\n        { x: -2, y: 0 },\n      ],\n      [\n        { x: -1, y: -1 },\n        { x: -2, y: -2 },\n      ],\n      [\n        { x: 0, y: -1 },\n        { x: 0, y: -2 },\n      ],\n      [\n        { x: 1, y: -1 },\n        { x: 2, y: -2 },\n      ],\n      [\n        { x: 1, y: 0 },\n        { x: 2, y: 0 },\n      ],\n    ];\n\n    const available: { x: number, y: number }[] = [];\n    for (const direction of danger) {\n      if (\n        board[y + direction[0].y]?.[x + direction[0].x] === Mark.X\n        && board[y + direction[1].y]?.[x + direction[1].x] === Mark.X\n      ) {\n        const front = {\n          x: lastMove.x + direction[0].x * -1,\n          y: lastMove.y + direction[0].y * -1,\n        }\n        const end = {\n          x: lastMove.x + direction[0].x * 3,\n          y: lastMove.y + direction[0].y * 3,\n        }\n\n        if (front.x > 0 && front.x <= this.size.x && front.y > 0 && front.y <= this.size.y)\n          if (board[front.y]?.[front.x] === Mark.None)\n            available.push(front)\n        if (end.x > 0 && end.x <= this.size.x && end.y > 0 && end.y <= this.size.y)\n        if (board[end.y]?.[end.x] === Mark.None)\n          available.push(end)\n      }\n    }\n\n    return available\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}