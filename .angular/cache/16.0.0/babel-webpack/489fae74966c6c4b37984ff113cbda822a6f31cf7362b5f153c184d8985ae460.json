{"ast":null,"code":"import { Mark } from \"./types\";\nexport class Opponent {\n  constructor(size) {\n    this.size = size;\n    this.lastAttack = null;\n    this.makeMove = (board, lastMove) => {\n      const moves = this.getMoves(board);\n      return moves[Math.floor(Math.random() * moves.length)];\n    };\n    this.getMoves = board => {\n      const moves = [];\n      for (let y = 0; y < board.length; y++) {\n        const row = board[y];\n        for (let x = 0; x < row.length; x++) {\n          if (board[y][x] === Mark.None) moves.push({\n            x,\n            y\n          });\n        }\n      }\n      return moves;\n    };\n    this.shouldIBeAlamed = (board, x, y) => {\n      const mark = board[y][x];\n      if (mark === Mark.None) return [];\n      return [{\n        x: 1,\n        y: 1\n      }, {\n        x: 0,\n        y: 1\n      }, {\n        x: -1,\n        y: 1\n      }, {\n        x: -1,\n        y: 0\n      }].filter(direction => board[y + direction.y] && board[y + direction.y][x + direction.x] === mark || board[y - direction.y] && board[y - direction.y][x - direction.x] === mark).reduce((acc, direction) => {\n        const aligned = [];\n        let i = 1;\n        while (true) {\n          const next = {\n            x: x + direction.x * i,\n            y: y + direction.y * i\n          };\n          if (board[next.y]?.[next.x] !== mark) break;\n          aligned.push(next);\n          i++;\n        }\n        i = 1;\n        while (true) {\n          const next = {\n            x: x - direction.x * i,\n            y: y - direction.y * i\n          };\n          if (board[next.y]?.[next.x] !== mark) break;\n          aligned.push(next);\n          i++;\n        }\n        if (aligned.length > 3) {\n          aligned.push({\n            x,\n            y\n          });\n          acc.push(aligned);\n        }\n        return acc;\n      }, []);\n    };\n  }\n}","map":{"version":3,"mappings":"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","names":["Mark","Opponent","constructor","size","lastAttack","makeMove","board","lastMove","moves","getMoves","Math","floor","random","length","y","row","x","None","push","shouldIBeAlamed","mark","filter","direction","reduce","acc","aligned","i","next"],"sourceRoot":"","sources":["/home/nikodem/projects/school/src/app/opponentai.ts"],"sourcesContent":["import { Mark } from \"./types\";\n\nexport class Opponent {\n  private lastAttack: { x: number, y: number } | null = null;\n\n  constructor(private size: { x: number, y: number }) {}\n\n  makeMove = (board: Mark[][], lastMove: { x: number, y: number }): { x: number, y: number } => {\n    const moves = this.getMoves(board);\n\n    return moves[Math.floor(Math.random() * moves.length)];\n  }\n\n  private getMoves = (board: Mark[][]): { x: number, y: number }[] => {\n    const moves: { x: number, y: number }[] = [];\n\n    for (let y = 0; y < board.length; y++) {\n      const row = board[y];\n      for (let x = 0; x < row.length; x++) {\n        if (board[y][x] === Mark.None) moves.push({ x, y });\n      }\n    }\n\n    return moves;\n  }\n\n  private shouldIBeAlamed = (board: Mark[][], x: number, y: number): boolean => {\n    const mark = board[y][x];\n\n    if (mark === Mark.None) return [];\n\n    return [\n      { x: 1, y: 1 },\n      { x: 0, y: 1 },\n      { x: -1, y: 1 },\n      { x: -1, y: 0 },\n    ].filter(direction =>\n      board[y + direction.y] && board[y + direction.y][x + direction.x] === mark\n      || board[y - direction.y] && board[y - direction.y][x - direction.x] === mark\n    )\n    .reduce((acc: { x: number, y: number }[][], direction) => {\n      const aligned = []\n\n      let i = 1\n\n      while (true) {\n        const next = {\n          x: x + direction.x * i,\n          y: y + direction.y * i,\n        }\n        if (board[next.y]?.[next.x] !== mark) break;\n\n        aligned.push(next)\n\n        i ++\n      }\n\n      i = 1\n\n      while (true) {\n        const next = {\n          x: x - direction.x * i,\n          y: y - direction.y * i,\n        }\n        if (board[next.y]?.[next.x] !== mark) break;\n\n        aligned.push(next)\n\n        i ++\n      }\n\n      if (aligned.length > 3) {\n        aligned.push({ x, y })\n        acc.push(aligned)\n      }\n\n      return acc\n    }, [])\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}