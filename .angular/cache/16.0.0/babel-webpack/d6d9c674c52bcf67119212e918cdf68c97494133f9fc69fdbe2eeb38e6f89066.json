{"ast":null,"code":"import { Mark } from \"./types\";\nexport class Opponent {\n  constructor(size) {\n    this.size = size;\n    this.nextAttack = null;\n    this.makeMove = (board, lastMove) => {\n      const moves = this.getMoves(board);\n      const a = this.getMyMarksAround(board, lastMove.x, lastMove.y);\n      const c = this.getMovesAround(board, lastMove.x, lastMove.y);\n      const b = a.find(({\n        x,\n        y\n      }) => board[2 * lastMove.y - y]?.[2 * lastMove.x - x] === Mark.None);\n      console.log('tilesAround', a);\n      console.log('moveWithNothingOpposite', b);\n      console.log('movesAround', c);\n      const getRandomMove = () => moves[Math.floor(Math.random() * moves.length)];\n      const move = this.shouldIBeAlamed(board, lastMove);\n      if (move && moves.includes(move)) return move;\n      if (!this.nextAttack) {\n        const randomMove = getRandomMove();\n        const movesAround = this.getMyMarksAround(board, randomMove.x, randomMove.y);\n        if (!movesAround) {\n          console.log('4', randomMove);\n          this.nextAttack = this.getMovesAround(board, randomMove.x, randomMove.y)[0] || null;\n          return randomMove;\n        }\n        const moveWithNothingOpposite = movesAround?.find(({\n          x,\n          y\n        }) => board[2 * randomMove.y - y][2 * randomMove.x - x] === Mark.None);\n        if (!moveWithNothingOpposite) {\n          this.nextAttack = this.getMovesAround(board, randomMove.x, randomMove.y)[0] || null;\n          return randomMove;\n        }\n        console.log('3', this.nextAttack);\n        this.nextAttack = moveWithNothingOpposite;\n        return randomMove;\n      }\n      const movesAround = this.getMyMarksAround(board, this.nextAttack.x, this.nextAttack.y);\n      if (!movesAround) {\n        console.log('2', this.nextAttack);\n        const attackThisTurn = this.nextAttack;\n        this.nextAttack = this.getMovesAround(board, this.nextAttack.x, this.nextAttack.y)[0] || null;\n        return attackThisTurn;\n      }\n      const moveWithNothingOpposite = movesAround?.find(({\n        x,\n        y\n      }) => board[2 * this.nextAttack.y - y][2 * this.nextAttack.x - x] === Mark.None);\n      if (!moveWithNothingOpposite) {\n        console.log('1', this.nextAttack);\n        const attackThisTurn = this.nextAttack;\n        this.nextAttack = this.getMovesAround(board, this.nextAttack.x, this.nextAttack.y)[0] || null;\n        return attackThisTurn;\n      }\n      console.log('5', this.nextAttack);\n      const attackThisTurn = this.nextAttack;\n      this.nextAttack = moveWithNothingOpposite;\n      return attackThisTurn;\n    };\n    this.getMoves = board => {\n      const moves = [];\n      for (let y = 0; y < board.length; y++) {\n        const row = board[y];\n        for (let x = 0; x < row.length; x++) {\n          if (board[y][x] === Mark.None) moves.push({\n            x,\n            y\n          });\n        }\n      }\n      return moves;\n    };\n    this.tilesWithMarkAound = (board, around, mark) => {\n      const {\n        x,\n        y\n      } = around;\n      const possibilities = [{\n        x: 1,\n        y: 1\n      }, {\n        x: 0,\n        y: 1\n      }, {\n        x: -1,\n        y: 1\n      }, {\n        x: -1,\n        y: 0\n      }, {\n        x: -1,\n        y: -1\n      }, {\n        x: 0,\n        y: -1\n      }, {\n        x: 1,\n        y: -1\n      }, {\n        x: 1,\n        y: 0\n      }];\n      const tilesAround = [];\n      for (const possibility of possibilities) {\n        const newX = x + possibility.x;\n        const newY = y + possibility.y;\n        if (newX >= 0 && newX < this.size.x && newY >= 0 && newY < this.size.y) if (board[newY][newX] === mark) tilesAround.push({\n          x: newX,\n          y: newY\n        });\n      }\n      return tilesAround;\n    };\n    this.getMovesAround = (board, x, y) => this.tilesWithMarkAound(board, {\n      x,\n      y\n    }, Mark.None);\n    this.getMyMarksAround = (board, x, y) => this.tilesWithMarkAound(board, {\n      x,\n      y\n    }, Mark.X);\n    this.getOppositeMoves = (moves, origin) => {\n      moves.map(({\n        x,\n        y\n      }) => ({\n        x: 2 * origin.x - x,\n        y: 2 * origin.y - y\n      }));\n      const {\n        x,\n        y\n      } = origin;\n      const possibilities = [{\n        x: 1,\n        y: 1\n      }, {\n        x: 0,\n        y: 1\n      }, {\n        x: -1,\n        y: 1\n      }, {\n        x: -1,\n        y: 0\n      }, {\n        x: -1,\n        y: -1\n      }, {\n        x: 0,\n        y: -1\n      }, {\n        x: 1,\n        y: -1\n      }, {\n        x: 1,\n        y: 0\n      }];\n      const tilesAround = [];\n      for (const possibility of possibilities) {\n        const newX = x + possibility.x;\n        const newY = y + possibility.y;\n        if (newX >= 0 && newX < this.size.x && newY >= 0 && newY < this.size.y) if (moves.includes(board[newY][newX])) tilesAround.push({\n          x: newX,\n          y: newY\n        });\n      }\n      return tilesAround;\n    };\n    this.shouldIBeAlamed = (board, lastMove) => {\n      const {\n        x,\n        y\n      } = lastMove;\n      const danger = [[{\n        x: 1,\n        y: 1\n      }, {\n        x: 2,\n        y: 2\n      }], [{\n        x: 0,\n        y: 1\n      }, {\n        x: 0,\n        y: 2\n      }], [{\n        x: -1,\n        y: 1\n      }, {\n        x: -2,\n        y: 2\n      }], [{\n        x: -1,\n        y: 0\n      }, {\n        x: -2,\n        y: 0\n      }], [{\n        x: -1,\n        y: -1\n      }, {\n        x: -2,\n        y: -2\n      }], [{\n        x: 0,\n        y: -1\n      }, {\n        x: 0,\n        y: -2\n      }], [{\n        x: 1,\n        y: -1\n      }, {\n        x: 2,\n        y: -2\n      }], [{\n        x: 1,\n        y: 0\n      }, {\n        x: 2,\n        y: 0\n      }]];\n      for (const direction of danger) {\n        if (board[y + direction[0].y]?.[x + direction[0].x] === Mark.X && board[y + direction[1].y]?.[x + direction[1].x] === Mark.X) {\n          if (board[y + direction[0].y]?.[x + direction[0].x] === Mark.None) {\n            return {\n              x: x + direction[0].x,\n              y: y + direction[0].y\n            };\n          } else if (board[y + direction[1].y * 3]?.[x + direction[1].x * 3] === Mark.None) {\n            return {\n              x: x - direction[1].x * 3,\n              y: y - direction[1].y * 3\n            };\n          }\n        }\n      }\n      return null;\n    };\n  }\n}","map":{"version":3,"mappings":"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","names":["Mark","Opponent","constructor","size","nextAttack","makeMove","board","lastMove","moves","getMoves","a","getMyMarksAround","x","y","c","getMovesAround","b","find","None","console","log","getRandomMove","Math","floor","random","length","move","shouldIBeAlamed","includes","randomMove","movesAround","moveWithNothingOpposite","attackThisTurn","row","push","tilesWithMarkAound","around","mark","possibilities","tilesAround","possibility","newX","newY","X","getOppositeMoves","origin","map","danger","direction"],"sourceRoot":"","sources":["/home/nikodem/projects/school/src/app/opponentai.ts"],"sourcesContent":["import { Mark } from \"./types\";\n\nexport class Opponent {\n  private nextAttack: { x: number, y: number } | null = null;\n\n  constructor(private size: { x: number, y: number }) {}\n\n  makeMove = (board: Mark[][], lastMove: { x: number, y: number }): { x: number, y: number } => {\n    const moves = this.getMoves(board);\n\n    const a = this.getMyMarksAround(board, lastMove.x, lastMove.y);\n    const c = this.getMovesAround(board, lastMove.x, lastMove.y);\n    const b = a.find(({ x, y }) => board[2 * lastMove.y - y]?.[2 * lastMove.x - x] === Mark.None);\n    console.log('tilesAround', a);\n    console.log('moveWithNothingOpposite', b);\n    console.log('movesAround', c);\n\n    const getRandomMove = () => moves[Math.floor(Math.random() * moves.length)];\n\n    const move = this.shouldIBeAlamed(board, lastMove);\n    if (move && moves.includes(move))\n      return move;\n\n    if (!this.nextAttack) {\n      const randomMove = getRandomMove();\n      const movesAround = this.getMyMarksAround(board, randomMove.x, randomMove.y)\n\n      if (!movesAround) {\n    console.log('4', randomMove);\n        this.nextAttack = this.getMovesAround(board, randomMove.x, randomMove.y)[0] || null\n        return randomMove;\n      }\n\n      const moveWithNothingOpposite = movesAround?.find(({ x, y }) => board[2 * randomMove.y - y][2 * randomMove.x - x] === Mark.None);\n      if (!moveWithNothingOpposite) {\n        this.nextAttack = this.getMovesAround(board, randomMove.x, randomMove.y)[0] || null\n        return randomMove;\n      }\n\n    console.log('3', this.nextAttack);\n      this.nextAttack = moveWithNothingOpposite;\n      return randomMove;\n    }\n\n    const movesAround = this.getMyMarksAround(board, this.nextAttack.x, this.nextAttack.y);\n    if (!movesAround) {\n    console.log('2', this.nextAttack);\n      const attackThisTurn = this.nextAttack;\n      this.nextAttack = this.getMovesAround(board, this.nextAttack.x, this.nextAttack.y)[0] || null\n      return attackThisTurn;\n    }\n\n    const moveWithNothingOpposite = movesAround?.find(({ x, y }) => board[2 * this.nextAttack!.y - y][2 * this.nextAttack!.x - x] === Mark.None);\n    if (!moveWithNothingOpposite) {\n    console.log('1', this.nextAttack);\n\n      const attackThisTurn = this.nextAttack;\n      this.nextAttack = this.getMovesAround(board, this.nextAttack.x, this.nextAttack.y)[0] || null\n      return attackThisTurn;\n    }\n\n    console.log('5', this.nextAttack);\n\n    const attackThisTurn = this.nextAttack;\n    this.nextAttack = moveWithNothingOpposite;\n    return attackThisTurn;\n  }\n\n  private getMoves = (board: Mark[][]): { x: number, y: number }[] => {\n    const moves: { x: number, y: number }[] = [];\n\n    for (let y = 0; y < board.length; y++) {\n      const row = board[y];\n      for (let x = 0; x < row.length; x++) {\n        if (board[y][x] === Mark.None) moves.push({ x, y });\n      }\n    }\n\n    return moves;\n  }\n\n  private tilesWithMarkAound = (board: Mark[][], around: { x: number, y: number }, mark: Mark): { x: number, y: number }[] => {\n    const { x, y } = around;\n\n    const possibilities = [\n      { x: 1, y: 1 },\n      { x: 0, y: 1 },\n      { x: -1, y: 1 },\n      { x: -1, y: 0 },\n      { x: -1, y: -1 },\n      { x: 0, y: -1 },\n      { x: 1, y: -1 },\n      { x: 1, y: 0 },\n    ];\n\n    const tilesAround: { x: number, y: number }[] = [];\n    for (const possibility of possibilities) {\n      const newX = x + possibility.x;\n      const newY = y + possibility.y;\n\n      if (newX >= 0 && newX < this.size.x && newY >= 0 && newY < this.size.y)\n        if (board[newY][newX] === mark)\n          tilesAround.push({ x: newX, y: newY });\n    }\n\n    return tilesAround;\n  }\n\n  private getMovesAround = (board: Mark[][], x: number, y: number): { x: number, y: number }[] =>\n    this.tilesWithMarkAound(board, { x, y }, Mark.None);\n\n  private getMyMarksAround = (board: Mark[][], x: number, y: number): { x: number, y: number }[] =>\n    this.tilesWithMarkAound(board, { x, y }, Mark.X);\n\n  private getOppositeMoves = (moves: { x: number, y: number }[], origin: { x: number, y: number }): { x: number, y: number }[] => {\n    moves.map(({ x, y }) => ({\n      x: 2 * origin.x - x,\n      y: 2 * origin.y - y,\n    }))\n    const { x, y } = origin;\n\n    const possibilities = [\n      { x: 1, y: 1 },\n      { x: 0, y: 1 },\n      { x: -1, y: 1 },\n      { x: -1, y: 0 },\n      { x: -1, y: -1 },\n      { x: 0, y: -1 },\n      { x: 1, y: -1 },\n      { x: 1, y: 0 },\n    ];\n\n    const tilesAround: { x: number, y: number }[] = [];\n    for (const possibility of possibilities) {\n      const newX = x + possibility.x;\n      const newY = y + possibility.y;\n\n      if (newX >= 0 && newX < this.size.x && newY >= 0 && newY < this.size.y)\n        if (moves.includes(board[newY][newX]))\n          tilesAround.push({ x: newX, y: newY });\n    }\n\n    return tilesAround;\n  }\n\n  private shouldIBeAlamed = (board: Mark[][], lastMove: { x: number, y: number }): { x: number, y: number } | null => {\n    const { x, y } = lastMove;\n\n    const danger = [\n      [\n        { x: 1, y: 1 },\n        { x: 2, y: 2 },\n      ],\n      [\n        { x: 0, y: 1 },\n        { x: 0, y: 2 },\n      ],\n      [\n        { x: -1, y: 1 },\n        { x: -2, y: 2 },\n      ],\n      [\n        { x: -1, y: 0 },\n        { x: -2, y: 0 },\n      ],\n      [\n        { x: -1, y: -1 },\n        { x: -2, y: -2 },\n      ],\n      [\n        { x: 0, y: -1 },\n        { x: 0, y: -2 },\n      ],\n      [\n        { x: 1, y: -1 },\n        { x: 2, y: -2 },\n      ],\n      [\n        { x: 1, y: 0 },\n        { x: 2, y: 0 },\n      ],\n    ];\n\n    for (const direction of danger) {\n      if (\n        board[y + direction[0].y]?.[x + direction[0].x] === Mark.X\n        && board[y + direction[1].y]?.[x + direction[1].x] === Mark.X\n      ) {\n        if (board[y + direction[0].y]?.[x + direction[0].x] === Mark.None) {\n          return {\n            x: x + direction[0].x,\n            y: y + direction[0].y,\n          };\n        } else if (board[y + direction[1].y * 3]?.[x + direction[1].x * 3] === Mark.None) {\n          return {\n            x: x - direction[1].x * 3,\n            y: y - direction[1].y * 3,\n          };\n        }\n      }\n    }\n\n    return null\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}