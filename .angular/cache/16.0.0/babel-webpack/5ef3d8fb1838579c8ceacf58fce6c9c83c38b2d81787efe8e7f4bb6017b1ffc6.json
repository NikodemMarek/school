{"ast":null,"code":"import { Mark } from \"./types\";\nexport class Opponent {\n  constructor(size) {\n    this.size = size;\n    this.nextAttack = null;\n    this.makeMove = (board, lastMove) => {\n      const moves = this.getMoves(board);\n      const move = this.shouldIBeAlamed(board, lastMove);\n      if (move) return move;\n      if (this.nextAttack) {}\n      return moves[Math.floor(Math.random() * moves.length)];\n    };\n    this.getMoves = board => {\n      const moves = [];\n      for (let y = 0; y < board.length; y++) {\n        const row = board[y];\n        for (let x = 0; x < row.length; x++) {\n          if (board[y][x] === Mark.None) moves.push({\n            x,\n            y\n          });\n        }\n      }\n      return moves;\n    };\n    this.shouldIBeAlamed = (board, lastMove) => {\n      const {\n        x,\n        y\n      } = lastMove;\n      const danger = [[{\n        x: 1,\n        y: 1\n      }, {\n        x: 2,\n        y: 2\n      }], [{\n        x: 0,\n        y: 1\n      }, {\n        x: 0,\n        y: 2\n      }], [{\n        x: -1,\n        y: 1\n      }, {\n        x: -2,\n        y: 2\n      }], [{\n        x: -1,\n        y: 0\n      }, {\n        x: -2,\n        y: 0\n      }], [{\n        x: -1,\n        y: -1\n      }, {\n        x: -2,\n        y: -2\n      }], [{\n        x: 0,\n        y: -1\n      }, {\n        x: 0,\n        y: -2\n      }], [{\n        x: 1,\n        y: -1\n      }, {\n        x: 2,\n        y: -2\n      }], [{\n        x: 1,\n        y: 0\n      }, {\n        x: 2,\n        y: 0\n      }]];\n      for (const direction of danger) {\n        if (board[y + direction[0].y]?.[x + direction[0].x] === Mark.X && board[y + direction[1].y]?.[x + direction[1].x] === Mark.X) {\n          if (board[y + direction[0].y]?.[x + direction[0].x] === Mark.None) {\n            return {\n              x: x + direction[0].x,\n              y: y + direction[0].y\n            };\n          } else if (board[y + direction[1].y * 3]?.[x + direction[1].x * 3] === Mark.None) {\n            return {\n              x: x - direction[1].x * 3,\n              y: y - direction[1].y * 3\n            };\n          }\n        }\n      }\n      return null;\n    };\n  }\n}","map":{"version":3,"mappings":"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","names":["Mark","Opponent","constructor","size","nextAttack","makeMove","board","lastMove","moves","getMoves","move","shouldIBeAlamed","Math","floor","random","length","y","row","x","None","push","danger","direction","X"],"sourceRoot":"","sources":["/home/nikodem/projects/school/src/app/opponentai.ts"],"sourcesContent":["import { Mark } from \"./types\";\n\nexport class Opponent {\n  private nextAttack: { x: number, y: number } | null = null;\n\n  constructor(private size: { x: number, y: number }) {}\n\n  makeMove = (board: Mark[][], lastMove: { x: number, y: number }): { x: number, y: number } => {\n    const moves = this.getMoves(board);\n\n    const move = this.shouldIBeAlamed(board, lastMove);\n    if (move) return move;\n\n    if (this.nextAttack) {\n\n    }\n\n    return moves[Math.floor(Math.random() * moves.length)];\n  }\n\n  private getMoves = (board: Mark[][]): { x: number, y: number }[] => {\n    const moves: { x: number, y: number }[] = [];\n\n    for (let y = 0; y < board.length; y++) {\n      const row = board[y];\n      for (let x = 0; x < row.length; x++) {\n        if (board[y][x] === Mark.None) moves.push({ x, y });\n      }\n    }\n\n    return moves;\n  }\n\n  private shouldIBeAlamed = (board: Mark[][], lastMove: { x: number, y: number }): { x: number, y: number } | null => {\n    const { x, y } = lastMove;\n\n    const danger = [\n      [\n        { x: 1, y: 1 },\n        { x: 2, y: 2 },\n      ],\n      [\n        { x: 0, y: 1 },\n        { x: 0, y: 2 },\n      ],\n      [\n        { x: -1, y: 1 },\n        { x: -2, y: 2 },\n      ],\n      [\n        { x: -1, y: 0 },\n        { x: -2, y: 0 },\n      ],\n      [\n        { x: -1, y: -1 },\n        { x: -2, y: -2 },\n      ],\n      [\n        { x: 0, y: -1 },\n        { x: 0, y: -2 },\n      ],\n      [\n        { x: 1, y: -1 },\n        { x: 2, y: -2 },\n      ],\n      [\n        { x: 1, y: 0 },\n        { x: 2, y: 0 },\n      ],\n    ];\n\n    for (const direction of danger) {\n      if (\n        board[y + direction[0].y]?.[x + direction[0].x] === Mark.X\n        && board[y + direction[1].y]?.[x + direction[1].x] === Mark.X\n      ) {\n        if (board[y + direction[0].y]?.[x + direction[0].x] === Mark.None) {\n          return {\n            x: x + direction[0].x,\n            y: y + direction[0].y,\n          };\n        } else if (board[y + direction[1].y * 3]?.[x + direction[1].x * 3] === Mark.None) {\n          return {\n            x: x - direction[1].x * 3,\n            y: y - direction[1].y * 3,\n          };\n        }\n      }\n    }\n\n    return null\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}